// Local testing script for Pollinations Image Cache
// Run with: node test-local.js

async function testSimilaritySearch() {
  console.log('Testing text similarity for image prompts...');
  
  // Sample prompts that should be semantically similar
  const similarPrompts = [
    'a beautiful sunset over mountains',
    'mountains with sunset in the background',
    'sunset landscape with mountains',
    'evening mountains with orange sky'
  ];
  
  // Sample prompts that should be different
  const differentPrompts = [
    'a cyberpunk city at night',
    'a cute cat sitting on a windowsill',
    'abstract colorful patterns'
  ];
  
  console.log('\nSimilar prompts should have high similarity scores:');
  
  // Compare first prompt with all others
  const basePrompt = similarPrompts[0];
  console.log(`Base prompt: "${basePrompt}"`);
  
  for (const prompt of [...similarPrompts.slice(1), ...differentPrompts]) {
    const similarity = calculateCosineSimilarity(
      mockEmbedding(basePrompt),
      mockEmbedding(prompt)
    );
    
    console.log(`"${prompt}" - Similarity: ${similarity.toFixed(4)} ${similarity > 0.8 ? '✅' : '❌'}`);
  }
}

// Simple mock function to simulate text embeddings
// In a real environment, this would use the AI model
function mockEmbedding(text) {
  // This is a very simplified mock - in reality, embeddings would be 
  // generated by a proper language model and have 512+ dimensions
  const hash = simpleHash(text.toLowerCase());
  
  // Create a pseudo-embedding vector with some similarity patterns
  // Words like "sunset" and "mountains" will create similar patterns
  const embedding = new Array(64).fill(0);
  
  for (let i = 0; i < 64; i++) {
    // Create a deterministic but distributed array of values
    embedding[i] = Math.sin(hash * (i + 1) * 0.01) * 0.5 + 0.5;
  }
  
  // Add some signal for common concepts
  if (text.includes('sunset')) {
    for (let i = 0; i < 10; i++) {
      embedding[i] += 0.3;
    }
  }
  
  if (text.includes('mountains')) {
    for (let i = 10; i < 20; i++) {
      embedding[i] += 0.3;
    }
  }
  
  if (text.includes('cyberpunk') || text.includes('city')) {
    for (let i = 20; i < 30; i++) {
      embedding[i] += 0.3;
    }
  }
  
  // Normalize to unit length
  const length = Math.sqrt(embedding.reduce((sum, val) => sum + val * val, 0));
  return embedding.map(val => val / length);
}

// Simple string hash function
function simpleHash(str) {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    hash = (hash * 31 + str.charCodeAt(i)) & 0xFFFFFFFF;
  }
  return hash;
}

// Calculate cosine similarity between two vectors
function calculateCosineSimilarity(vecA, vecB) {
  if (vecA.length !== vecB.length) {
    throw new Error('Vectors must have the same dimensions');
  }
  
  let dotProduct = 0;
  let magA = 0;
  let magB = 0;
  
  for (let i = 0; i < vecA.length; i++) {
    dotProduct += vecA[i] * vecB[i];
    magA += vecA[i] * vecA[i];
    magB += vecB[i] * vecB[i];
  }
  
  magA = Math.sqrt(magA);
  magB = Math.sqrt(magB);
  
  if (magA === 0 || magB === 0) {
    return 0;
  }
  
  return dotProduct / (magA * magB);
}

// Test cache key generation
function testCacheKeys() {
  console.log('\nTesting cache key generation:');
  
  const tests = [
    {
      prompt: 'a beautiful sunset',
      params: { width: 1024, height: 768, model: 'flux', seed: 42 }
    },
    {
      prompt: 'a beautiful sunset',
      params: { width: 1024, height: 768, model: 'flux', seed: 43 }  // Different seed
    },
    {
      prompt: 'a beautiful sunset',
      params: { width: 512, height: 512, model: 'flux', seed: 42 }   // Different size
    },
    {
      prompt: 'A Beautiful Sunset',                                 // Same prompt, different case
      params: { width: 1024, height: 768, model: 'flux', seed: 42 }
    }
  ];
  
  for (const test of tests) {
    const key = generateCacheKey(test.prompt, test.params);
    console.log(`Prompt: "${test.prompt}", Params: ${JSON.stringify(test.params)}`);
    console.log(`Cache key: ${key}\n`);
  }
}

// Simplified version of the cache key generation from worker.js
function generateCacheKey(prompt, params) {
  const relevantParams = {
    model: params.model || 'flux',
    seed: params.seed,
    width: params.width,
    height: params.height,
  };
  
  const paramsString = Object.entries(relevantParams)
    .filter(([_, value]) => value !== undefined)
    .sort(([keyA], [keyB]) => keyA.localeCompare(keyB))
    .map(([key, value]) => `${key}=${value}`)
    .join('&');
    
  return `${prompt}|${paramsString}`;
}

// Run the tests
(async function runTests() {
  console.log('='.repeat(60));
  console.log('Pollinations Image Cache - Local Testing Script');
  console.log('='.repeat(60));
  
  console.log('\nThis script helps verify the key components of the caching system:');
  console.log('1. Text embedding similarity for finding related prompts');
  console.log('2. Cache key generation for exact matching');
  console.log('\nIn a production environment, these functions would interact with');
  console.log('Cloudflare AI, R2, Vectorize, and KV storage.');
  
  await testSimilaritySearch();
  testCacheKeys();
  
  console.log('\nTo deploy this worker to Cloudflare:');
  console.log('1. Configure wrangler.toml with your account details');
  console.log('2. Run: npm install');
  console.log('3. Run: npx wrangler deploy');
  console.log('='.repeat(60));
})();
